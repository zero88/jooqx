# Features

## Result Data transformation

### To Json Record

```java
SelectForUpdateStep<AuthorsRecord> query = jooqx.dsl()
                                                .selectFrom(table)
                                                .where(table.COUNTRY.eq("USA"))
                                                .orderBy(table.NAME.desc())
                                                .limit(1)
                                                .offset(1);
jooqx.execute(query, DSLAdapter.fetchJsonRecord(query.asTable()), ar -> System.out.println(ar.result.toJson()));
// output: {"id":8,"name":"Christian Wenz","country":"USA"}
```

### To Record or POJO

```java
SelectWhereStep<AuthorsRecord> query = jooqx.dsl().selectFrom(table);
//Authors is POJO class that generated by jOOQ
jooqx.execute(query, DSLAdapter.fetchMany(table, Authors.class), ar -> {
    List<Authors> authors = ar.result()
    Authors author = authors.get(0);
    System.out.println(author.getId());
    System.out.println(author.getCountry());
});
// output: 1
// output: UK
```

### By jOOQ fields

```java
Books table = catalog().PUBLIC.BOOKS;
InsertResultStep<BooksRecord> insert = jooqx.dsl()
                                            .insertInto(table, table.TITLE).values("aha")
                                            .returning();
jooqx.execute(insert, DSLAdapter.fetchOne(table, Collections.singletonList(table.ID)), ar -> {
    Record record = ar.result();
    System.out.println(record.getValue(0));
});
// output: 10
```

Please checkout 2 [DSL adapter](core/src/main/java/io/zero88/jooqx/DSLAdapter.java) to see which method that suite for you.

## SQL Batch

```java
Books table = catalog().PUBLIC.BOOKS;
BooksRecord rec1 = new BooksRecord().setTitle("b1");
BooksRecord rec2 = new BooksRecord().setTitle("b2");
BooksRecord rec3 = new BooksRecord().setTitle("qwe");

BindBatchValues bindValues = new BindBatchValues().register(table.TITLE).add(rec1, rec2, rec3);
InsertResultStep<BooksRecord> insert = jooqx.dsl()
                                            .insertInto(table)
                                            .set(bindValues.getDummyValues())
                                            .returning();
jooqx.batch(insert, bindValues, ar -> System.out.println(ar.result));
// {total = 2, success = 2}
```

With `reactive SQL client`, it is possible to returning list of records and able to transformation as above.

```java
InsertResultStep<AuthorsRecord> insert = jooqx.dsl()
                                            .insertInto(table)
                                            .set(bindValues.getDummyValues())
                                            .returning(table.ID);
jooqx.batch(insert, bindValues,
            DSLAdapter.fetchMany(table, jooqx.dsl().newRecord(table.ID)), handler);
```

## SQL transaction

```java
jooqx.transaction().run(tx -> {
    InsertResultStep<BooksRecord> q1 = tx.dsl()
                                        .insertInto(table, table.ID, table.TITLE)
                                        .values(Arrays.asList(DSL.defaultValue(table.ID), "abc"))
                                        .returning(table.ID);
    InsertResultStep<BooksRecord> q2 = tx.dsl()
                                        .insertInto(table, table.ID, table.TITLE)
                                        .values(Arrays.asList(DSL.defaultValue(table.ID), "xyz"))
                                        .returning(table.ID);
    // Avoid using the scope from outside the transaction:
    jooqx.execute(...);
    
    // ...but using context within the transaction scope:
    return tx.execute(q1, DSLAdapter.fetchOne(table))
             .flatMap(b1 -> tx.execute(q2, DSLAdapter.fetchOne(table)));
}, ar -> {});
```

## SQL Exception handler

Basically, `exception` in execution time will be thrown by each particular `jdbc` driver or `reactive SQL driver`, it can be spaghetti code, dealing with `exception`, then `jooqx` is able to centralize any exception with properly `SQL state` that thanks to `DataAccessException` in `jOOQ`.

It is easy to configure when building `executor`

```java
// with Reactive PostgreSQL sql client exception
ReactiveJooqx jooqx = ReactiveJooqx.builder().vertx(vertx)
                                            .dsl(dsl)
                                            .sqlClient(sqlClient)
                                            .errorConverter(new PgErrorConverter())
                                            .build();

// with JDBC sql client exception

//reactive
ReactiveJooqx jooqx = ReactiveJooqx.builder().vertx(vertx)
                                            .dsl(dsl)
                                            .sqlClient(sqlClient)
                                            .errorConverter(new JDBCErrorConverter())
                                            .build();
//legacy
LegacyJooqx jooqx = LegacyJooqx.builder().vertx(vertx)
                                        .dsl(dsl)
                                        .sqlClient(sqlClient)
                                        .errorConverter(new JDBCErrorConverter())
                                        .build();
```

And so more, you can convert to your existing application exception (must `extends RuntimeException`) by

```java
// For example from JDBCErrorConverter
new JDBCErrorConverter().andThen(dataAccessException -> new DatabaseError(ErrorCode.Duplicate, dataAccessException))
```

## Rxify

`jOOQ.x` supports out of the box [Vert.x RxJava](https://vertx.io/docs/vertx-rx/java2/)

To use `jOOQ.x API` for RxJava2, add the following dependency to the dependencies section of your build descriptor:

- Maven (in your `pom.xml`)

```xml
<dependency>
   <groupId>io.vertx</groupId>
   <artifactId>vertx-rx-java2</artifactId>
   <version>4.0.3</version>
</dependency>
<dependency>
  <groupId>io.github.zero88</groupId>
  <artifactId>jooqx-core</artifactId>
  <version>1.0.0</version>
</dependency>
<!-- Other database libs depends on your application -->
```

- Gradle (in your `build.gradle` or `build.gradle.kts`)

```gradle
dependencies {
    api("io.github.zero88:jooqx-core:1.0.0")
    api("io.vertx:vertx-rx-java2:4.0.3")
    // Other database libs depends on your application
}
```

Then you can use same as `Vertx rx-java2 Rxified API`

```java
ReactiveJooqx jooqx = ReactiveJooqx.newInstance(io.zero88.jooqx.ReactiveJooqx.poolBuilder()
                                       .vertx(vertx)
                                       .dsl(dsl)
                                       .sqlClient(sqlClient)
                                       .build());
jooqx.rxExecute(jooqx.dsl().selectFrom(table), DSLAdapter.fetchJsonRecords(table))
     .subscribe(records -> {}, err -> {});
```

## Data type mapper

`Vert.x Reactive SQL client` on each Database can provide set of different object types with JDBC then `jOOQ` system cannot understand. It leads to 4 use cases:

- Both same data type. Hurray!!! No need do anything
- Vertx SQL data type (a.k.a database type) is different to `jOOQ` JDBC type, then you might want one of these solutions:
  - Use `jOOQ` data type as an user type (a.k.a your application type)
  - Use `Vertx` data type as an user type
  - Keep `Vertx` data type as database type, `jOOQ` is intermediate type, and your custom type in application

So, to resolve these situations, `jooqx` introduce [DataTypeMapper](core/src/main/java/io/zero88/jooqx/datatype/DataTypeMapper.java) to make three-way-conversion that based on `jOOQ converter`. Besides that, `jooqx` provides some default mapper utilities for make converter is easier with `UserTypeAsJooqType` and `UserTypeAsVertxType`.

Let's see some example in `gradle jooq`:

With PostgreSQL, `Interval` data type is presented by:

- `Vert.x` PostgreSQL interval: `io.vertx.pgclient.data.Interval`
- `jOOQ` interval: `org.jooq.types.YearToSecond`

```groovy
generator.apply {
    name = "org.jooq.codegen.DefaultGenerator"
    strategy.name = "org.jooq.codegen.DefaultGeneratorStrategy"
    database.apply {
        name = "org.jooq.meta.postgres.PostgresDatabase"
        inputSchema = "public"
        withForcedTypes(
            // Use Vertx Type means io.vertx.pgclient.data.Interval is database type and user type
            ForcedType().withUserType("io.vertx.pgclient.data.Interval")
                .withConverter("io.zero88.jooqx.datatype.UserTypeAsVertxType.create(new io.zero88.jooqx.spi.pg.datatype.IntervalConverter())")
                .withIncludeTypes("INTERVAL")
                .withIncludeExpression("f_interval_1"),
            // Use Jooq Type means io.vertx.pgclient.data.Interval is database type, org.jooq.types.YearToSecond is jOOQ type and user type
            ForcedType().withUserType("io.vertx.pgclient.data.Interval")
                .withConverter("io.zero88.jooqx.datatype.UserTypeAsJooqType.create(new io.zero88.jooqx.spi.pg.datatype.IntervalConverter())")
                .withIncludeTypes("INTERVAL")
                .withIncludeExpression("f_interval_2"),
            // Three-way-conversion: io.vertx.pgclient.data.Interval is database type, org.jooq.types.YearToSecond is jOOQ intermediate type and user type is java.time.Duration
            ForcedType()
                .withUserType("java.time.Duration")
                .withConverter("io.zero88.jooqx.integtest.spi.pg.CustomInterval")
                .withIncludeTypes("INTERVAL")
                .withIncludeExpression("f_interval_3")
        )
    }
```

So, after generation, we have

```java
assert record.getFInterval1().getClass().getName() == "io.vertx.pgclient.data.Interval"
assert record.getFInterval2().getClass().getName() == "org.jooq.types.YearToSecond"
assert record.getFInterval3().getClass().getName() == "java.time.Duration"
```

## Test fixtures API

`jooqx` provides a test API to you can try out and provide a produce a minimum reproducer. Simplify add lib in your build descriptor.

The database provider can be `DB memory` or `DB in container` (thanks to [TestContainer](https://www.testcontainers.org/))

Please checkout more in [How to write new test](DEVELOP.md#how-to-write-new-test)
