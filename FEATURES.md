# Features

## Result Data transformation

### To Json Record

```java
SelectForUpdateStep<AuthorsRecord> query = jooqx.dsl()
                                                .selectFrom(table)
                                                .where(table.COUNTRY.eq("USA"))
                                                .orderBy(table.NAME.desc())
                                                .limit(1)
                                                .offset(1);
jooqx.execute(query, DSLAdapter.fetchJsonRecord(query.asTable()), ar -> System.out.println(ar.result.toJson()));
// output: {"id":8,"name":"Christian Wenz","country":"USA"}
```

### To Record or POJO

```java
SelectWhereStep<AuthorsRecord> query = jooqx.dsl().selectFrom(table);
//Authors is POJO class that generated by jOOQ
jooqx.execute(query, DSLAdapter.fetchMany(table, Authors.class), ar -> {
    List<Authors> authors = ar.result()
    Authors author = authors.get(0);
    System.out.println(author.getId());
    System.out.println(author.getCountry());
});
// output: 1
// output: UK
```

### By jOOQ fields

```java
Books table = catalog().PUBLIC.BOOKS;
InsertResultStep<BooksRecord> insert = jooqx.dsl()
                                            .insertInto(table, table.TITLE).values("aha")
                                            .returning();
jooqx.execute(insert, DSLAdapter.fetchOne(table, Collections.singletonList(table.ID)), ar -> {
    Record record = ar.result();
    System.out.println(record.getValue(0));
});
// output: 10
```

Please checkout 2 [DSL adapter](core/src/main/java/io/zero88/jooqx/DSLAdapter.java) to see which method that suite for you.

## SQL Batch

```java
Books table = catalog().PUBLIC.BOOKS;
BooksRecord rec1 = new BooksRecord().setTitle("b1");
BooksRecord rec2 = new BooksRecord().setTitle("b2");
BooksRecord rec3 = new BooksRecord().setTitle("qwe");

BindBatchValues bindValues = new BindBatchValues().register(table.TITLE).add(rec1, rec2, rec3);
InsertResultStep<BooksRecord> insert = jooqx.dsl()
                                            .insertInto(table)
                                            .set(bindValues.getDummyValues())
                                            .returning();
jooqx.batch(insert, bindValues, ar -> System.out.println(ar.result));
// {total = 2, success = 2}
```

With `reactive SQL client`, it is possible to returning list of records and able to transformation as above.

```java
InsertResultStep<AuthorsRecord> insert = jooqx.dsl()
                                            .insertInto(table)
                                            .set(bindValues.getDummyValues())
                                            .returning(table.ID);
jooqx.batch(insert, bindValues,
                       DSLAdapter.fetchMany(table, jooqx.dsl().newRecord(table.ID)), handler);
```

## SQL transaction

```java
jooqx.transaction().run(tx -> {
    InsertResultStep<BooksRecord> q1 = tx.dsl()
                                        .insertInto(table, table.ID, table.TITLE)
                                        .values(Arrays.asList(DSL.defaultValue(table.ID), "abc"))
                                        .returning(table.ID);
    InsertResultStep<BooksRecord> q2 = tx.dsl()
                                        .insertInto(table, table.ID, table.TITLE)
                                        .values(Arrays.asList(DSL.defaultValue(table.ID), "xyz"))
                                        .returning(table.ID);
    // Avoid using the scope from outside the transaction:
    jooqx.execute(...);
    
    // ...but using context within the transaction scope:
    return tx.execute(q1, DSLAdapter.fetchOne(table))
             .flatMap(b1 -> tx.execute(q2, DSLAdapter.fetchOne(table)));
}, ar -> {});
```

## SQL Exception handler

Basically, `exception` in execution time will be thrown by each particular `jdbc` driver or `reactive SQL driver`, it can be spaghetti code, dealing with `exception`, then `jooqx` is able to centralize any exception with properly `SQL state` that thanks to `DataAccessException` in `jOOQ`.

It is easy to configure when building `executor`

```java
// with Reactive PostgreSQL sql client exception
ReactiveJooqx jooqx = ReactiveJooqx.builder().vertx(vertx)
                                                            .dsl(dsl)
                                                            .sqlClient(sqlClient)
                                                            .errorConverter(new PgErrorConverter())
                                                            .build();

// with JDBC sql client exception

//reactive
ReactiveJooqx jooqx = ReactiveJooqx.builder().vertx(vertx)
                                                                .dsl(dsl)
                                                                .sqlClient(sqlClient)
                                                                .errorConverter(new JDBCErrorConverter())
                                                                .build();
//legacy
LegacyJooqx jooqx = LegacyJooqx.builder().vertx(vertx)
                                                .dsl(dsl)
                                                .sqlClient(sqlClient)
                                                .errorConverter(new JDBCErrorConverter())
                                                .build();
```

And so more, you can convert to your existing application exception (must `extends RuntimeException`) by

```java
// For example from JDBCErrorConverter
new JDBCErrorConverter().to(dataAccessException -> new DatabaseError(ErrorCode.Duplicate, dataAccessException))
```

## Rxify

`jOOQ.x` supports out of the box [Vert.x RxJava](https://vertx.io/docs/vertx-rx/java2/)

To use `jOOQ.x API` for RxJava2, add the following dependency to the dependencies section of your build descriptor:

- Maven (in your `pom.xml`)

```xml
<dependency>
   <groupId>io.vertx</groupId>
   <artifactId>vertx-rx-java2</artifactId>
   <version>4.0.3</version>
</dependency>
<dependency>
  <groupId>io.github.zero88</groupId>
  <artifactId>jooqx-core</artifactId>
  <version>1.0.0</version>
</dependency>
<!-- Other database libs depends on your application -->
```

- Gradle (in your `build.gradle` or `build.gradle.kts`)

```gradle
dependencies {
    api("io.github.zero88:jooqx-core:1.0.0")
    api("io.vertx:vertx-rx-java2:4.0.3")
    // Other database libs depends on your application
}
```

Then you can use same as `Vertx rx-java2 Rxified API`

```java
ReactiveJooqx jooqx = ReactiveJooqx.newInstance(io.zero88.jooqx.ReactiveJooqx.poolBuilder()
                                       .vertx(vertx)
                                       .dsl(dsl)
                                       .sqlClient(sqlClient)
                                       .build());
jooqx.rxExecute(jooqx.dsl().selectFrom(table), DSLAdapter.fetchJsonRecords(table))
     .subscribe(records -> {}, err -> {});
```
